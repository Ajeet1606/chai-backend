Project Setup:
- npm init
- create Readme.md 
- git init
- create gitignore
- create public & public/temp for storing images or some static files.
- git doesn't track empty folders, so we add a .gitkeep file for now.
- install nodemon for restarting the server on each update.
- create src
- create app.js, constants.js & index.js in src.
- create folders: controllers, db, models, routes, utils.
- install prettier on project basis not on vs code: when multiple people are working on same project, they can have different spacing config etc, which can lead to conflicts sometimes, so when prettier is working inside project, it has a localized setting, it keeps same for all.
- to setup prettier:
    - create file .prettierrc in root.
    - create .prettierignore file: to not apply prettier settings in some files.


------------------------------------ DATABASE CONNECTION --------------------------------
- create a project in your mongodb atlas org.
- create a user in database access.
- setup your IP in network access.
- get MONGODB_URI and add it into .env file.
- install dotenv for proper usage of env variables.
- install mongoose for database connection.
- always remember db connection is async.

------------------------------------ dotenv setup ---------------------------------------
- to get the env variables working and imported properly, we use dotenv package.
- it provides only commonjs method of importing, which is:
    "require('dotenv).config({path: 'path of .env'})"

- but here we want to use modulejs method of import, so we use an expermental trick to get it done.
1. import dotenv from "dotenv";
dotenv.config({path: 'path of env'})
2. add "-r dotenv/config --experimental-json-modules" in your dev command, which now looks like:
"dev": "nodemon -r dotenv/config --experimental-json-modules src/index.js"

---------------------------------- MIDDLEWARES ------------------------------------
- a layer of software that sits between the core application logic and the server, acting as a bridge for incoming requests and outgoing responses. it helps us in performing various tasks in req, res cycle.
[req, res] cycle:
client req -> middleware -> core application logic -> middleware -> server sends response

definition: Middleware (also called pre and post hooks) are functions which are passed control during execution of asynchronous functions. Middleware is specified on the schema level and is useful for writing plugins.

types:
1. Document middleware
2. Model middleware
3. Aggregate middleware
4. Query middleware

- CORS is a middleware example, to use them, we do app.use(cors())
- app.use is used to setup middlewares or do some configuration.

- Standard Error and response format setup.

----------------------- lecture 9 -------------------
- create user & video models
- install mongoose-aggregate-paginate-v2 package.

- install bcrypt and jsonwebtoken for password encryption/decryption and getting tokens respectively.
- we use all above 3 packages in user/video models.

- how do we use them?
- mongoose provides some middlewares/hooks, one such is pre hook which runs just before saving data into model on every call, so we do our work using this.

JWT: it is a bearer token.
JWT library gives us tokens but it takes some values to create them:
- payload
- privateKeys
- expiry
there's are multiple ways to do depending on what data we're using to create.


------------------------ lecture 10 --------------------
-- file uploading:
- cloud storage providers: cloudinary
- packages to help file uploading: multer, express-fileupload

install cloudinary & multer packages.

process: take file from frontend, store on our backend server temporarily, now upload it on cloud provider (takes file path from server, stores on cloud and then deletes from server, as unlinking), for safety purpose we stored it on backend as well, if we failed to upload on cloud once, we can try again.